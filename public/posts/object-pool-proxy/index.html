<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="
Note: This is the second post in a series about an object pooling pattern. You can follow along with code in this repo on Github. The repo will be steps ahead of this series, so don&rsquo;t worry if there&rsquo;s things in there I haven&rsquo;t explained.


Dynamic Proxy
Why a Dynamic Proxy
Proxy generator
Wrapper
Combining the wrapper and the interceptor
Summary

Dynamic Proxy
For our proxy object, we&rsquo;re going to use Dynamic Proxy from the Castle Project. This package allows us to create a pass-through object for any type that implements the interface we&rsquo;re going to be pooling.">  

  <title>
    
      Object Pool - Proxying calls
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2020-10-21 11:30:56 &#43;0000 &#43;0000">
                            2020-10-21
                        </time>
                    </p>
                </div>

<article>
    <h1>Object Pool - Proxying calls</h1>

    

    <blockquote>
<p><strong>Note:</strong> This is the second post in a <a href="/tags/object-pool">series</a> about an object pooling pattern. You can follow along with code in this <a href="https://github.com/gregbair/object-pool">repo on Github</a>. The repo will be steps ahead of this series, so don&rsquo;t worry if there&rsquo;s things in there I haven&rsquo;t explained.</p>
</blockquote>
<ul>
<li><a href="#dynamic-proxy">Dynamic Proxy</a></li>
<li><a href="#why-a-dynamic-proxy">Why a Dynamic Proxy</a></li>
<li><a href="#proxy-generator">Proxy generator</a></li>
<li><a href="#wrapper">Wrapper</a></li>
<li><a href="#combining-the-wrapper-and-the-interceptor">Combining the wrapper and the interceptor</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<h2 id="dynamic-proxy">Dynamic Proxy</h2>
<p>For our proxy object, we&rsquo;re going to use <a href="https://www.castleproject.org/projects/dynamicproxy/">Dynamic Proxy</a> from the Castle Project. This package allows us to create a pass-through object for any type that implements the interface we&rsquo;re going to be pooling.</p>
<p>Dynamic proxying is a form of the <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> that doesn&rsquo;t care what the underlying object is. Since C# is a strongly-typed language, it&rsquo;s burdensome to create a proxy that can handle any type - you&rsquo;d need to know at compile time (when you write your code) what type you&rsquo;re proxying.</p>
<p>Dynamic proxying hijacks the runtime typing, using reflection to create stub and proxy classes at runtime to allow more flexibility in situations like ours where we want to work with types that are only known at runtime.</p>
<p>We&rsquo;re going to pass through any method call except one - <code>Dispose()</code>. We&rsquo;ll use that to return our object to the pool.</p>
<h2 id="why-a-dynamic-proxy">Why a Dynamic Proxy</h2>
<p>If you know the type of object you&rsquo;re pooling ahead of time, you don&rsquo;t need to use dynamic proxying. You can just manually create a proxy object that implements the same interface, and pass through all the calls you need to, and not pass through the ones you don&rsquo;t. For our pool, though, we&rsquo;re trying to make something more general so that it&rsquo;s reusable.</p>
<h2 id="proxy-generator">Proxy generator</h2>
<p>The dynamic proxy mechanism from the Castle Project uses what&rsquo;s called a proxy generator. In short, we define an interceptor that passes through all the method calls (except <code>Dispose</code>), and use that to generate at runtime a proxy object. Note that this does incur a small bit of overhead, so if you&rsquo;re only pooling one type, and know that type, you can skip doing this.</p>
<h2 id="wrapper">Wrapper</h2>
<p>We also need something to wrap our object and put some metadata on it that will be  useful to the pool. Attributes like which pool it belongs to, a unique ID, and the target object are the metadata we&rsquo;re storing for now. Later we might add when the object was created if we need to dispose &ldquo;stale&rdquo; objects.</p>
<h2 id="combining-the-wrapper-and-the-interceptor">Combining the wrapper and the interceptor</h2>
<p>For simplicity, we can combine both of these concepts into a single class, called our <a href="https://github.com/gregbair/lagoon/blob/main/src/Lagoon/PooledObjectWrapper.cs#L13"><code>PooledObjectWrapper&lt;TObject&gt;</code></a>.</p>
<p>As part of its implementaiton of <code>IInterceptor</code>, we have a method <code>Intercept(IInvocation invocation)</code> that we&rsquo;ll use to intercept method calls. Let&rsquo;s take a look at that method below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#75715e">// IInvocation is an object passed in by Castle Project containing metadata</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// about the method call.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Intercept(IInvocation invocation)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (invocation <span style="color:#66d9ef">is</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(invocation));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (!invocation.Method.Name.Equals(<span style="color:#e6db74">&#34;Dispose&#34;</span>, StringComparison.OrdinalIgnoreCase))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// We only want to intercept the Dispose method.</span>
</span></span><span style="display:flex;"><span>        invocation.Proceed();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If Dispose is called, return this object to the pool.</span>
</span></span><span style="display:flex;"><span>        _pool.ReturnObject(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Because of the way we are intercepting the <code>Dispose</code> method, we can hijack it to not actually dispose the object, but instead return it to our pool.</p>
<p>Our interceptor/wrapper also has its own dispose method, which will be called by the pool in its pruning operation (we&rsquo;ll cover that later). It actually disposes the wrapped object.</p>
<h2 id="summary">Summary</h2>
<p>We looked at how dynamic proxies work, and introduced an interceptor and a wrapper for our object.</p>
<p>For further info about dynamic proxies and the interceptor, see the Castle Project&rsquo;s <a href="https://github.com/castleproject/Core/blob/master/docs/dynamicproxy.md">docs</a>.</p>
<p>Next, we&rsquo;ll look into how the pool manages retrieving, creating, activating, and disposing objects.</p>

</article>

            </div>
        </main>
    </body></html>
